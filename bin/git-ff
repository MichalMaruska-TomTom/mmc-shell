#!/bin/zsh -feu

source /usr/share/mmc-shell/git-functions.sh
source /usr/share/mmc-shell/mmc-functions.sh
colors

trap 'print ${PROGRAM-$0} ERROR: $LINENO:  $ZSH_EVAL_CONTEXT $0 >&2' ZERR
# set -x
usage() {
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [-h] [-f] [-l] [-u] [--] [remote | {remote} {local branch}]

Fast-forward to remote head, stashing around.
-f not only fast-forward !
-b rebase.
-l list
-u fetch/update first


-h help
By default {branch} is the current one on the favorite remote.

EOF
    unsetopt POSIX_ARGZERO
}

force=n
rebase=n
list=no
fetch_too=no
while getopts :bfhlu OPT; do
    case $OPT in
        h|+h)
            usage
            exit 0
            ;;
        b)
            rebase=y
            ;;
        f)
            force=y
            ;;
        l)
            list=yes
            ;;
        u)
            fetch_too=yes
            ;;
        *)
            usage >&2
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [[ $# -gt 2 ]]; then
    usage >&2
    exit 2
fi

# find where to
# I need:
# - remote host,
# - local branch, and
# - the remote branch!
# $1 is remote or remote-branch
if [[ $# = 2 ]]
then
    if is_git_remote $1; then
        GIT_REMOTE_NAME=$1
        target=remotes/$1/$2
        local_branch=$2
    else
        die "confused"
    fi

elif [[ $# = 1 ]]; then

    if is_git_remote_branch $1
    then
        # select the branch
        target=remotes/$1
    elif is_git_remote $1
    then
        GIT_REMOTE_NAME=$1
        # todo: the same I'm on
        local_branch=$(current_branch_name)
        target=$GIT_REMOTE_NAME/$local_branch
    else
        target=$1
    fi
    shift
else
    # find the friend remote:
    set_remote_name

    # todo: the same I'm on
    local_branch=$(current_branch_name)

    # default:
    target=$GIT_REMOTE_NAME/$local_branch
fi

if [[ $fetch_too = yes ]]
then
    git fetch $GIT_REMOTE_NAME $local_branch
fi

if [[ $list = yes ]]
then
    set -x
    git log $local_branch..$target
    exit 0
fi


# if the fast-forward would move ahead!
git_ff_to_cautiously()
{
    # given $ref and $force
    local ref=$1

    info "will fast-forward $local_branch to $ref"
    # unless we are on it already:
    if [[ $(git rev-parse $local_branch) != $(git rev-parse $ref) ]]; then

        if [[ $rebase = y ]];
        then
            mmc_stash_if_non_clean 'stash for git-ff/rebase'

            # todo: switch back!
            previous_branch=$(current_branch_name)
            if [[ $previous_branch != $local_branch ]]; then
                git switch $local_branch
            fi

            # automatically squash  !fixup commits:
            cecho hiyellow "rebase & unstash:"
            git rebase --autosquash $ref

            # return:
            git switch -- # git switch $previous_branch
            mmc_unstash_if_stashed
            cecho hiyellow "done: rebased & unstashed"
        elif [[ $force = y ]]  || git merge-base --is-ancestor $local_branch $ref
        then
            previous_branch=$(current_branch_name)

            if [[ $previous_branch != $local_branch ]]
            then
                git branch --force $local_branch $ref
            else
                # the current, so stash!
                if git merge --autostash --ff-only $ref;
                then
                    cecho hiyellow "ff (without conflicts w/ dirty files)"
                else
                    # touching timestamps:
                    # mmc_stash_if_non_clean "merge fast-forward"
                    # stash_if_non_clean

                    # Could not Fast-Forward, so only force can help:
                    if [[ $force = y ]]; then
                        cecho hiyellow "Forcing reset to $ref"
                        git reset --hard $ref

                    else
                        # this case is impossible?
                        cecho hiyellow "Fast-Forward failed"
                        : do-nothing
                        # git checkout $branch
                        # git merge --ff-only $ref
                    fi
                    # mmc_unstash_if_stashed
                fi
            fi
        else
            # todo: if ancestor, print a different message.
            echo >&2 "cannot fast-forward to $ref $fg[red]not our descendant$reset_color"
        fi
    fi
}

git_ff_to_cautiously $target
