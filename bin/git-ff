#!/bin/zsh -feu

source /usr/share/mmc-shell/git-functions.sh
source /usr/share/mmc-shell/mmc-functions.sh
colors

# set -x
usage() {
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [-h] [-f] [--] [remote | remote branch]

Fast-forward to remote head, stashing around.
-f not only fast-forward !
-b rebase.
-l list

-h help
By default {branch} is the current one on the favorite remote.

EOF
    unsetopt POSIX_ARGZERO
}

force=n
rebase=n
list=no
while getopts :bfhl OPT; do
    case $OPT in
        h|+h)
            usage
            exit 0
            ;;
        b)
            rebase=y
            ;;
        f)
            force=y
            ;;
        l)
            list=yes
            ;;
        *)
            usage >&2
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [[ $# -gt 2 ]]; then
    usage >&2
    exit 2
fi

# find where to
# I need:
# - remote host,
# - local branch, and
# - the remote branch!
# $1 is remote or remote-branch
if [[ $# = 2 ]]
then
    if is_git_remote $1; then
        target=remotes/$1/$2
        local_branch=$2
    else
        die "confused"
    fi

elif [[ $# = 1 ]]; then

    if is_git_remote_branch $1
    then
        # select the branch
        target=remotes/$1
    elif is_git_remote $1
    then
        GIT_REMOTE_NAME=$1
        # todo: the same I'm on
        local_branch=$(current_branch_name)
        target=$GIT_REMOTE_NAME/$local_branch
    else
        target=$1
    fi
    shift
else
    # find the friend remote:
    set_remote_name

    # todo: the same I'm on
    local_branch=$(current_branch_name)

    # default:
    target=$GIT_REMOTE_NAME/$local_branch
fi


if [[ $list = yes ]];
then
    set -x
    git log $local_branch..$target
    exit 0
fi


# new:
stash_commit=

mmc_stash_if_non_clean()
{
    local message=$1
    stash_commit=$(git stash create $message)
    # is it HEAD ?
    if [[ -n $stash_commit ]]; then
        # this message goes into .git/logs/refs/stash
        # 'stash for git-ff'
        git stash store -m $message $stash_commit
    fi
}

mmc_unstash_if_stashed()
{
    if [[ -n "$stash_commit" ]]
    then
        cecho yellow "unstashing now."
        git stash pop --quiet
    fi
}

# if the fast-forward would move ahead!
git_ff_to_cautiously()
{
    # given $ref and $force
    local ref=$1

    # unless we are on it already:
    if [[ $(git rev-parse $local_branch) != $(git rev-parse $ref) ]]; then

        if [[ $rebase = y ]];
        then
            mmc_stash_if_non_clean 'stash for git-ff/rebase'

            # todo: switch back!
            previous_branch=$(current_branch_name)
            if [[ $previous_branch != $local_branch ]]; then
                git switch $local_branch
            fi

            # automatically squash  !fixup commits:
            cecho hiyellow "rebase & unstash:"
            git rebase --autosquash $ref

            # return:
            git switch -- # git switch $previous_branch
            mmc_unstash_if_stashed
            cecho hiyellow "done: rebased & unstashed"
        elif [[ $force = y ]]  || git merge-base --is-ancestor $local_branch $ref
        then
            previous_branch=$(current_branch_name)

            if [[ $previous_branch != $local_branch ]]
            then
                git branch --force $local_branch $ref
            else
                # touching timestamps:
                stash_if_non_clean "merge fast-forward"

                if [[ $force = y ]]; then
                    git reset --hard $ref
                else
                    # git checkout $branch
                    git merge --ff-only $ref
                fi
                unstash_if_stashed
                cecho hiyellow "ff & unstashed"
            fi
        else
            # todo: if ancestor, print a different message.
            echo >&2 cannot fast-forward to $ref $fg[red]not our descendant$reset_color
        fi
    fi
}

git_ff_to_cautiously $target
