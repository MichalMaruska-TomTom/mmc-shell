#!/bin/zsh -feu

source /usr/share/mmc-shell/git-functions.sh
source /usr/share/mmc-shell/mmc-functions.sh
colors

trap 'print ${PROGRAM-$0} ERROR: $LINENO:  $ZSH_EVAL_CONTEXT $0 >&2' ZERR

# so 2 steps:
# switch (maybe in worktree) to local branch
# fetch --- either pull or ...
#

usage() {
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [-h] [-f] [-l] [-u] [--] [remote | {remote} {local branch}]

Fast-forward to remote head, stashing around.
* if no remote --> just from the __followed__ branch
* if remote --> same branch (name) on remote
* if even local-branch given -> switch to it first.

-f not only fast-forward !
-b rebase.
-l list
-u fetch/update first
-v verbose

-h help
By default {branch} is the current one on the favorite remote.

EOF
    unsetopt POSIX_ARGZERO
}

force=n # act even if not descendant
rebase=n # if not descendant -> rebase
list_difference=no  # show the git log between.

fetch_too=no # start with git fetch ... from which remote?
verbose=no

while getopts :bfhluv OPT; do
    case $OPT in
        h|+h)
            usage
            exit 0
            ;;
        b)
            rebase=y
            ;;
        f)
            force=y
            ;;
        l)
            list_difference=yes
            ;;
        u)
            fetch_too=yes
            ;;
        v)
            verbose=yes
            ;;
        *)
            usage >&2
            exit 2
    esac
done
shift OPTIND-1
OPTIND=1

if [[ $# -gt 2 ]]; then
    usage >&2
    exit 2
fi

# find where to
# I need:
# - remote host,
# - local branch, and
# - the remote branch!

# use-cases:
# I'm on a branch X and want Y to move to H/Y
#                   and want to move to its  ---
#                   and want to move to H/X
#
# $1 is local branch -> either move to its or ...
# $1 is remote or remote-branch

# So I need to set 3 variables:
# local branch, remote host, and remote branch

# local_branch
# GIT_REMOTE_NAME
# target
#    remotes/GIT_REMOTE_NAME/target

# sets GIT_REMOTE_NAME and target
find_defaults_for_local_branch()
{
    local local_branch=$1
    local remote
    local remote_branch

    if git config branch.${local_branch}.remote >&/dev/null
    then
        remote=$(git config branch.$local_branch.remote)
        GIT_REMOTE_NAME=$remote

        remote_branch=$(git config branch.$local_branch.merge)
        #drop refs/heads
        target=${remote_branch#refs/heads/}

    else
        # find the friend remote:
        echo "the branch $local_branch does not follow anything on remotes">&2
        return 1
        exit 1
        set_remote_name

        # todo: the same I'm on

        # default:
        # remotes/$GIT_REMOTE_NAME/
        target=$local_branch
    fi
}


if [[ $# = 0 ]]
then
    local_branch=$(current_branch_name)
    find_defaults_for_local_branch $local_branch

elif [[ $# = 1 ]]; then
    # fixme:  branch, remote,
    if git-branch-exists $1
    then
        local_branch=$1
        find_defaults_for_local_branch $local_branch

    elif is_git_remote $1
    then
         # host/branch
         local_branch=$(current_branch_name)
         GIT_REMOTE_NAME=$1

         # remotes/$GIT_REMOTE_NAME/
         target=$local_branch
    #
    # elif is_git_remote_branch
    else
        target=$1
    fi
    shift

elif [[ $# = 2 ]]
then
    if is_git_remote $1 &>/dev/null; then
        GIT_REMOTE_NAME=$1
        # todo: ask git wh
        target=remotes/$1/$2
        local_branch=$2
    elif is_git_remote_branch $1; then
        target=$1
        local_branch=$2
    else
        die "confused"
    fi
fi

cecho red "$local_branch $GIT_REMOTE_NAME $target"

if [[ $fetch_too = yes ]]
then
    git fetch $GIT_REMOTE_NAME $local_branch
fi

if [[ $list_difference = yes ]]
then
    git log --oneline $local_branch..remotes/$GIT_REMOTE_NAME/$target
    # exit 0
fi

# if the fast-forward would move ahead!
git_ff_to_cautiously()
{
    # given $ref and $force
    local local_branch=$1
    local ref=$2


    info "will fast-forward $local_branch to $ref"
    # unless we are on it already:

    if [[ $verbose = yes ]]; then
        set -x
    fi

    # todo: check that the ref exists!
    if ! git rev-parse $ref -- ; then
        git branch -a
        die "the remote branch does not exist: $ref"
    fi

    echo "compare $local_branch  $(git rev-parse $local_branch) != $(git rev-parse $ref) $ref">&2
    if [[ $(git rev-parse $local_branch) != $(git rev-parse $ref) ]]; then

        if [[ $rebase = y ]];
        then
            mmc_stash_if_non_clean 'stash for git-ff/rebase'

            # todo: switch back!
            previous_branch=$(current_branch_name)
            if [[ $previous_branch != $local_branch ]]; then
                git switch $local_branch
            fi

            # automatically squash  !fixup commits:
            cecho hiyellow "rebase & unstash:"
            git rebase --autosquash $ref

            # return:
            git switch -- # git switch $previous_branch
            mmc_unstash_if_stashed
            cecho hiyellow "done: rebased & unstashed"
        elif [[ $force = y ]]  || git merge-base --is-ancestor $local_branch $ref
        then
            previous_branch=$(current_branch_name)

            if [[ $previous_branch != $local_branch ]]
            then
                git branch --force $local_branch $ref
            else
                # the current, so stash!
                if git merge --autostash --ff-only $ref;
                then
                    cecho hiyellow "ff (without conflicts w/ dirty files)"
                else
                    # touching timestamps:
                    # mmc_stash_if_non_clean "merge fast-forward"
                    # stash_if_non_clean

                    # Could not Fast-Forward, so only force can help:
                    if [[ $force = y ]]; then
                        cecho hiyellow "Forcing reset to $ref"
                        git reset --hard $ref

                    else
                        # this case is impossible?
                        cecho hiyellow "Fast-Forward failed"
                        : do-nothing
                        # git checkout $branch
                        # git merge --ff-only $ref
                    fi
                    # mmc_unstash_if_stashed
                fi
            fi
        else
            # todo: if ancestor, print a different message.
            echo >&2 "cannot fast-forward to $ref $fg[red]not our descendant$reset_color"
        fi
    else
        echo >&2 "$local_branch and $ref resolve both to " $(git rev-parse $local_branch)
    fi
}


git_ff_to_cautiously $local_branch "remotes/$GIT_REMOTE_NAME/$target"
