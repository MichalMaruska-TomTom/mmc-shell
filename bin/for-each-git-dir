#! /bin/zsh -feu

# this is recursive. First time it invokes the find
# and the second time (invoked by find) it will invoke (correctly)
# the user's command.
# The key aim is to invoke the command in the "found" directory.

if getopt -T; then # should test (( $? = -4 ))
    echo "incompatible  getopt(1) installed. Abort"
    exit -1
fi


: ${FOR_EACH_DIR_CHILD=0}
export FOR_EACH_DIR_CHILD

usage()
{
    cat <<EOF
Usage $0 [-s] [-d]

--debug  | -d  debug ...
--pass   | -p  pass the relative path as first argument.
--help   | -h
--wait   | -w  wait 3 seconds between
EOF
}


## Executed in the parent:
if [ $FOR_EACH_DIR_CHILD = 0 ]; then

    # declare
    typeset -a print_args
    print_args=()
    # print_args=(-printf '\033[01;33m%p\033[0m\n')

    typeset -a args
    args=()
    # default
    FOR_EACH_DIR_CHILD=2
    AFTER=()
    cmd_options=$(getopt --name $0 --shell bash \
	--longoptions pass,debug,help,wait --options pdhw \
	-- "$@" ) || { usage && exit 1 }
    eval set -- "$cmd_options"

    while (( $# > 0 )) do
	case $1 in
	    -p|--pass)
		FOR_EACH_DIR_CHILD=1
		;;
	    -d|--debug)
		args+=(-d)
		;;
	    --help|-h)
		usage
		exit 0
		;;
	    --wait| -w)
		AFTER=(-exec sleep 3 \;)
		;;
	    --)
		shift
		break;
	esac
	shift
    done


    # skip  .repo
    export FOR_EACH_BASE_DIR=$(pwd)
    find . -name .repo -prune \
	 -o \
	 -type d -name .git $print_args \
	 -exec $0 \{\} $args "$@" \; $AFTER -prune
# todo -execdir

else
    # return from the .git
    dir=$(expr match $1 '\(.*\)/.git')
    shift
    cd $dir

    if [ $1 = "-d" ]; then
	cecho cyan $dir
	shift;
    fi
    # $(git describe) ;
    # set -x
    if [ $FOR_EACH_DIR_CHILD = 2 ]; then
	eval $@[1] $@[2,-1]
    else
	eval $@[1] $dir $@[2,-1]
    fi
fi

