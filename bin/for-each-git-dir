#! /usr/bin/zsh -feu

# this is recursive. First time it invokes the find
# and the second time (invoked by find) it will invoke (correctly)
# the user's command.
# The key aim is to invoke the command in the "found" directory.

: ${FOR_EACH_DIR_CHILD=0}
export FOR_EACH_DIR_CHILD


usage()
{
    cat <<EOF
Usage $0 [-s] [-d]

-d debug ...
-s don't pass the relative path as first argument.
EOF
}

if [ $FOR_EACH_DIR_CHILD = 0 ]; then

    # declare
    typeset -a print_args
    print_args=()
    # print_args=(-printf '\033[01;33m%p\033[0m\n')

    typeset -a args
    args=()
    # default
    FOR_EACH_DIR_CHILD=1

    while getopts :sdh OPT; do
	case $OPT in
	    s|+s)
		FOR_EACH_DIR_CHILD=2
		;;
	    d|+d)
		args+=(-d)
		;;
	    h|+h)
		usage
		exit 0
		;;
	    *)
		print "usage: ${0##*/} [+-sdh} [--] ARGS..."
		exit 2
	esac
    done
    shift OPTIND-1
    OPTIND=1


    export FOR_EACH_BASE_DIR=$(pwd)
    find . -type d -name .git $print_args \
	 -exec $0 \{\} $args "$@" \;

# foreach d (*(/)) {echo $d; pushd $d; cecho green $(git describe) ; popd }
else
    # return from the .git
    dir=$(expr match $1 '\(.*\)/.git')
    shift
    cd $dir

    if [ $1 = "-d" ]; then
	cecho green $dir
	shift;
    fi
    # $(git describe) ;
    # set -x
    if [ $FOR_EACH_DIR_CHILD = 2 ]; then
	eval $@[1] $@[2,-1]
    else
	eval $@[1] $dir $@[2,-1]
    fi
fi

