#!/bin/zsh -feu

if getopt -T; then # should test (( $? = -4 ))
    echo "incompatible  getopt(1) installed. Abort"
    exit -1
fi

trap 'print ${PROGRAM-$0} ERROR: $LINENO:  $ZSH_EVAL_CONTEXT $0 >&2' ZERR

# Enter a container with 32-bit environment.

# 4 scenarios to invoke this:
# --boot  .... start a systemd as init
# --start .... bind & mount & invoke SHELL as init.

# cmd                 .... run the cmd inside a _running_
# --interactive .. will bind-mount standard user's dirs.

# --start cmd  run inside a _started_


#               full      |   user shell
# start       --boot      |   --start
# join-shell    cmd       |
# join          empty cmd



# defaults:
CONTAINER_DIR=

distro=sid
arch=x32
# i386

VERBOSE=n
as_root=n
boot=n
start=n
interactive=n
workdir=""
# todo:  --root

arguments=()

typeset -a bind_mounts=(
)

# full machine:
readonly special_id=$(id -u michal)
# my Source repositories to be able to build.
typeset -r new_machine_mounts=(/run/tmp/ /home/)
# sorry this break dbus on the host!  /run/user/$special_id
# you can only bind  /run/user/$special_id/pulse maybe.

# the `standalone' scenario
readonly user_bind_mounts=(
    $HOME
    /dev/
)


usage()
{
    setopt POSIX_ARGZERO
    cat <<EOF
usage: ${0##*/} [+-n] [-c dir] [-b dir] [--] ARGS...

# commands:
--start
-B --boot   ...


-n --private-network ... setup private network (no networking at start?)
-b --bind  .. add directory as --bind mount.
-r  ... start as root
-c  ... chdir at start
-C --container  dir
-h  --usage --help ..
EOF
}

cmd_options=$(getopt --name $0 --shell bash \
                     --options a:b:BcC:d:himn:rsv \
                     --longoptions \
                     arch:,bind:,boot,chdir:,container:,distro:,help,name,private-network,root,start,usage,verbose \
                     -- "$@" ) || { usage; exit 1 }
# name: n:
eval set -- "$cmd_options"

while (( $# > 0 )) do
      case $1 in
          -a | --arch)
              shift
              arch=$1
              ;;
          -b | --bind )
              shift
              bind_mounts+=("$1")
              ;;
          -B | --boot)
              boot=y
              arguments+=(--boot)
              # /dev/ ->no
              bind_mounts+=($new_machine_mounts)
              ;;
          --container)
              shift
              CONTAINER_DIR="$1"
              ;;
          -c | --chdir )
              shift
              workdir="$1"
              ;;
          -d | --distro)
              shift
              arch=$1
              ;;

          -h | --usage | --help)
              usage
              exit 0
              ;;

          -n | --name)
               shift
               machine_name="$1"
               ;;

          -p| --private-network)
              arguments+=(--private-network)
              ;;
          -r | --root )
              # as root!
              as_root=y
              ;;
          -s | --start)
              start=y
              ;;
          -v | --verbose)
              VERBOSE=y
              ;;
          -- )
              shift
              break
              ;;
          *)
              echo "unknown option $1">&2
              usage >&2
              exit 2
      esac
      shift
done

if [ $VERBOSE = y ]; then set -x;fi

if [[ -t 1 && $# = 0 ]]; then
    interactive=y
fi


# hostname is derived from this
if [[ ! -v machine_name ]]; then
   machine_name=$distro-$arch
fi

if [[ -z $CONTAINER_DIR ]]; then
    CONTAINER_DIR=/var/lib/machines/$distro-$arch
fi


rewrite_array()
{
    # array=$1
    local prefix=$2
    local suffix=$3

    local i
    for ((i=1; i<= ${#bind_mounts}; i++))
        {
            bind_mounts[$i]="$prefix$bind_mounts[$i]$suffix"
        }
    # echo $bind_mounts
}

# --setenv --register=no
if [[ $VERBOSE = y ]]; then set -x;fi

# sudo systemd-nspawn --bind=/dev/  --directory /var/lib/machines/sid-x32 '--bind=/home/michal' --capability=all  --boot --private-users=no


readonly FAKE_USER_DIR=/run/user-ro/

if [[ $start = y || $boot = y ]]; then

    if [[ $interactive = y && $boot = n ]]; then
       # this would be used if we --start:
       bind_mounts+=($user_bind_mounts)
    fi

    rewrite_array bind_mounts "--bind=" ""

    # this is needed for ... start only?
    arguments+=(--machine="$machine_name")
    arguments+=(--bind-ro /run/user:$FAKE_USER_DIR)
    arguments+=(--private-users=no)

    if [[ $boot = n && $as_root = n ]]
    then
        arguments+=(--user $USER)
    fi

    if [[ $workdir != "" ]];
    then
        arguments+=(--chdir "$workdir")
    fi


    command=()
    # for interactive use?

    if [[ $start = y ]]; then
        # This is needed if I run Zsh, and want the Job-control (C-z does not work without it)
        # this was useful when: systemd-nspawn ...i.e. 1-access only.
        command=(/usr/bin/setsid -c -w)

        if [[ $interactive = y ]]; then
            command+=(/bin/zsh -l)
        else
            command+=($@)
        fi
    fi

    if [[ $VERBOSE = y ]]; then
       set -x
    fi
    exec sudo systemd-nspawn \
         --directory $CONTAINER_DIR \
         --capability=all \
         $bind_mounts \
         $arguments $command
else

    # mmc: let's try:
    args=($arguments)

    if [[ $as_root = n ]]; then
         args+=( --uid=$(id --user) )
    fi

    if [[ -n ${GITSHA-} ]]; then
        args+=(--setenv "GITSHA=$GITSHA")
    fi

    args+=(--setenv "MAKEFLAGS=$MAKEFLAGS"
           --setenv PULSE_SERVER=$FAKE_USER_DIR/1000/pulse/native
           --setenv DISPLAY=$DISPLAY)

    # `join' an existing:
    if [[ $interactive = y ]]; then
        # --setenv "inside_container"
        if [[ $VERBOSE = y ]]; then
            set -x
        fi
        exec sudo machinectl $args shell $machine_name
    else

        if [[ -n "$workdir" ]]; then
            # bug:
            args+=(-- /bin/bash -c)
            # I need the $@ to be inside the d-quotes!

            # This is ugly: once it is a string, and below it is array!
            cmd="cd $workdir; $@"
        else
            cmd=$@
        fi

        if [[ $VERBOSE = y ]]; then
            set -x
        fi
        exec sudo systemd-run --pty --machine=$machine_name \
             $args $cmd
    fi
fi
